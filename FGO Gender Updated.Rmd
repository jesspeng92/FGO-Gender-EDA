---
title: "The Possible Gender Discrepancy in Fate/Grand Order"
output:
  html_document:
    code_folding: hide
    df_print: paged
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

![](FGO_files/FGO Images/FGO Screen.jpg) 

# Introduction
## What is Fate/Grand Order?
[Fate Grand Order](https://www.fate-go.jp/), or more commonly referred to as FGO, is a free-to-play Japanese mobile game developed by Lasengle and published by Aniplex. It is based on Type_Moon's Fate/Stay Night franchise.

The game is a turn-based game rpg where the player, or "Master", summons and commands characters or game-units known as "Servants" to battle enemies. Servants are typically obtained through the gacha system, though some can be obtained as rewards for completing events. 

It was released on July 29th, 2015 for Android, August 12th, 2015 for iOS. The [North American server](https://fate-go.us/) was released in June 25th, 2017. 

## Why care?
Mobile gacha games have grown in popularity within recent years with the rise of FGO, Fire Emblem Heroes (FEH), Genshin Impact, and more.
The game's signature mechanic is the gacha system, which is like a lottery based system. The player spends in-game currency to roll for units. Some characters are more difficult to obtain than others based on rarity and availability status. High rarity servants are more difficult to obtain, and limited servants are only available for a set period of time. Players can obtain game currency either by progressing in the game or though real-world purchases.
FGO is a free-to-play game, meaning it does not require money in order to advance in the game. However, many players spend money to purchase in-game currency so they can obtain their favorite characters (usually high-rarity limited character). This is, to my knowledge, FGO's only source of revenue. In July 2021, the game grossed $5.4 billion worldwide, making it the seventh highest-grossing mobile game of all time.

## Goal
My friends and I often complain about the gender discrepancy in the game. Quite frankly, we believe the game has a gender bias towards females, evident through the gender distribution of the game's summer servants and welfare servants. FGO releases 7 new servants every summer, and there hasn't been a single male servant. 
As such, in this project, I aim to explore the trends of various servants in relation to their gender and test whether the game is biased towards a certain gender.

# Data Collection
I chose to scrape the data using rvest from [Fate Grand Order wiki](https://fategrandorder.fandom.com/wiki/Fate/Grand_Order_Wikia), a fan-run site that stores information about different servants and their statistics. While a [Kaggle dataset exists](https://www.kaggle.com/datasets/victorsoeiro/fategrand-order-servants), I wanted some other variables.

```{r}
library(rvest)
library(purrr)
library(xml2)
library(stringi)
library(ggplot2)
library(plotly)
library(GGally)
library(tidyverse)
library(Hmisc)
library(RColorBrewer)
```

I scraped my information from two different parts of the site. First, I obtained the list of servants and their availability status. Then I scraped each servants' information from their respective web-pages using the list of servants.
```{r}
page <- read_html("https://fategrandorder.fandom.com/wiki/Servants") %>%
    html_nodes(".wikitable") %>%
    html_nodes("a") %>% 
    html_attr(., "title")

page <- unique(page)
is.beast <- which(page == "Beast")
servant_classes <- page[1:is.beast-1]
```

```{r}
links <- paste0("https://fategrandorder.fandom.com/wiki/", 
              gsub("\\s+", "_", servant_classes))
```

```{r}
url <- "https://fategrandorder.fandom.com/wiki/Servant_List"
page <- url %>%
        read_html() %>% html_nodes(".sortable") %>% html_nodes("tbody") %>% html_nodes("tr") %>% html_nodes("td>:not(.servant_icon)")

has.span <- grepl("span", page)
page[has.span] <- page[has.span] %>% html_nodes("a")

categories_and_servants <- page %>% html_attr(., "title")
head(categories_and_servants)
```

Now we have our data. Currently, we have a single vector with servant names and category identifiers. We'll separate the list to match each servant to their respective category. Some servants have multiple availability statuses, so some servants will have multiple values.
```{r}
is_servant <- function(info) {
  is_category <- grepl("Category", info) | grepl("Event Reward", info)
  return(!is_category)
}

servant_categories <- is_servant(categories_and_servants)
```

```{r}
get_servant_availability_list <- function(info, category) {
  y <- as.numeric(category)
  z <- cumsum(y)
  z <- as.factor(z)
  class.split <- unname(split(info, f=z))
  
  make_unlimited <- function(servant) {
    if(length(servant) == 1) {
      servant <- c(servant, "Unlimited")
    }
    return(servant)
  }
  
  class.split <- lapply(class.split, make_unlimited)
  names(class.split) <- map_chr(class.split, 1)
  class.split <- lapply(class.split, function(x) x[-1])
  return(unlist(class.split))
}


servant_availability_list <- get_servant_availability_list(info = categories_and_servants, category = servant_categories)
```

```{r}
get_servant_list <- function(servants) {
  servant <- gsub("[0-9]", "", servants)
  return(servant)
}

list_of_servants <- get_servant_list(names(servant_availability_list))
```

```{r}
get_availability_list <- function(availabilites) {
  availability <- trimws(gsub("Category:", "", availabilites))
  return(unname(availability))
}

list_of_availability <- get_availability_list(servant_availability_list)
```

```{r}
unique_servants <- unique(list_of_servants)
```

Now we can get each servant's information from their personal wiki bio. Some characters have ascii characters in their names, which need to be converted into their raw characters so that the hyperlink works properly.
```{r}
get_char_for_link <- function(character){
  x <- unlist(strsplit(character, ""), recursive=FALSE)
  ascii.index <- is.na(iconv(x, from="latin1", to="ASCII"))
  x.ascii <- iconv(x[ascii.index], from="latin1", to="ASCII", sub="byte")
  x.ascii <- gsub(">", "", gsub("<", "%", toupper(as.character(x.ascii))))
  x[ascii.index] <- x.ascii
  x <- paste(x, collapse="")
  return(x)
}

servant_links <- unlist(lapply(unique_servants, get_char_for_link))
servant_links[10:14]
```

```{r}
links <- paste0("https://fategrandorder.fandom.com/wiki/", 
              gsub("\\s+", "_", servant_links))
```

```{r}
get_servant_base <- function(link){
  servant <- read_html(link) %>%
    html_nodes(".ServantInfoWrapper") %>%
    html_text()
  servant <- strsplit(servant, "Sprite")
  servant <- unlist(servant, recursive= FALSE)
  servant <- gsub('[\t]', '', servant)
  return(servant)
}

servant.raw.text <- lapply(links, get_servant_base)
servant.raw.text.copy <- servant.raw.text
```

```{r}
get_servant_name_info <- function(text){
  servant.name <- trimws(text[[1]], which = c("both", "left", "right"), "[\\h\\v]")
  servant.name <- unlist(strsplit(servant.name, "\n+"), recursive=FALSE)
  servant.name <- unlist(lapply(servant.name, trimws), recursive=FALSE)
  servant.name <- rev(servant.name[1:2])
  rarity <- gsub("\\s+", "", servant.name[2])
  rarity <- nchar(rarity)
  return(rarity)
}

servant.rarity <- unlist(lapply(servant.raw.text.copy, get_servant_name_info))
servant.rarity[unique_servants == "Beast IV: L"] <- 5
servant.rarity <- as.character(servant.rarity)
```

```{r}
get_servant_class <- function(link){
  class <- read_html(link) %>% html_nodes(".ServantInfoClass") %>% html_nodes("a") %>% html_attr(., "title")
  return(class)
}

servant.class <- unlist(lapply(links, get_servant_class))
is.beast <- grepl("Beast", servant.class)
servant.class[is.beast] <- "Beast"
```

```{r}
get_some_stats <- function(text) {
  text <- paste0(text, collapse="")
  text <- strsplit(text, "Japanese Name:")
  text <- unlist(text, recursive=FALSE)
  text[2] <- paste0("Japanese Name:", text[2])
  servant.stat <- trimws(text[2], which = c("both", "left", "right"), "[\n+]")
  servant.stat <- trimws(servant.stat, "l")
  servant.stat <- unlist(strsplit(servant.stat, "\n+"), recursive=FALSE)
  servant.active.skill <- match("Active Skills", servant.stat)
  servant.stat <- servant.stat[3:servant.active.skill-1]
  servant.stat <- gsub("Base:", "", servant.stat)

  servant.stat <- strsplit(servant.stat, ":")
  servant.stat.names <- trimws(unlist(map(servant.stat, 1)))
  servant.stat.stat <- trimws(unlist(map(servant.stat, 2)))
  servant.stat.stat <- gsub("\\s*\\([^\\)]+\\)","", servant.stat.stat)

  is.hp.atk <- servant.stat.names=="ATK" | servant.stat.names=="HP"
  test <- servant.stat.names[is.hp.atk]
  test2 <- paste0(test, "&Max ", test)
  servant.stat.names[is.hp.atk] <- test2
  stat.names2 <- unlist(strsplit(servant.stat.names, "&"))
  servant.stat.names <- stat.names2

  servant.stat.stat[is.hp.atk] <- strsplit(servant.stat.stat[is.hp.atk], "/")
  servant.stat.stat <- unlist(servant.stat.stat)
  return(list(servant.stat.names, servant.stat.stat))
}


servant.stats <- lapply(servant.raw.text.copy, get_some_stats)
```

## Exceptions
We check if there are any exceptions to our generic data. If it doesn't follow the specificed output, then we'll fix it.
```{r}
identifiers.length <- unlist(lapply(map(servant.stats,1), length))
info.length <- unlist(lapply(map(servant.stats, 2), length))
exceptions <- unique_servants[!identifiers.length == info.length | (info.length != 24  & info.length != 23)]
exceptions
```

Just fixing some exceptions manually here. Some characters were missing inputs because the site didn't include them, some characters had unique exceptions. 
Jekyll and Hyde is officially one character, but he has attributes of two characters. I chose to make him one character. 
Beast IV:L has limited info, so I chose to manually input her info and placed unknown attributes with "???" or "None".

Santa Karna
```{r}
is.karna <- unique_servants == "Karna (Santa)"
karna.santa <- unlist(servant.stats[is.karna], recursive=FALSE)
karna.index <- which(karna.santa[[1]]=="Growth Curve")
karna.stats <- karna.santa[[2]]
karna.stats <- c(karna.stats[1:karna.index-1], "Semi S", karna.stats[karna.index:length(karna.stats)])
karna.stats <- list(karna.stats)
karna.santa <- list(c(karna.santa[1], karna.stats))
servant.stats[is.karna] <- karna.santa
```

Cu Chulainn
```{r}
is.cu1 <- which(grepl("Chulainn", unique_servants))[1]
cu <- unlist(servant.stats[is.cu1], recursive=FALSE)
cu.aka <- cu[[1]][2]
cu[[1]] <- cu[[1]][-2]
cu[[2]][1] <- paste0(cu.aka, cu[[2]][1])
cu[[2]] <- unlist(strsplit(cu[[2]], "/"))
servant.stats[is.cu1] <- list(cu)
```

Bartholomew Roberts
```{r}
is.barth <- which(unique_servants=="Bartholomew Roberts")
barth <- servant.stats[[is.barth]]
barth[[1]] <- c("ID", barth[[1]])
barth[[2]][1] <- gsub("?ID", "", barth[[2]][1])
barth[[2]] <- c("257", barth[[2]])
servant.stats[[is.barth]] <- barth
```

Shuten Doji (Caster)
```{r}
is.sdc <- grepl("ji \\(Caster\\)", unique_servants)
sdc <- unlist(servant.stats[is.sdc], recursive=FALSE)
sdc.index <- which(sdc[[1]]=="Growth Curve")
sdc.stats <- sdc[[2]]
sdc.stats <- c(sdc.stats[1:sdc.index-1], "Reverse S", sdc.stats[sdc.index:length(sdc.stats)])
sdc.stats <- list(sdc.stats)
sdc <- list(c(sdc[1], sdc.stats))
servant.stats[is.sdc] <- sdc
```

Jekyll and Hyde
```{r}
is.hyde <- grepl("Hyde", unique_servants)
jekyl.hyde <- unlist(servant.stats[is.hyde], recursive=FALSE)

a <- strsplit(jekyl.hyde[[2]], "/")
hyde.info <- sapply(a, length) == 2

jekyl <- jekyl.hyde
jekyl.stat <- jekyl[[2]]
jekyl.stat[hyde.info] <- unlist(map(a[hyde.info], 1))
jekyl.stat <- trimws(gsub("\\(\\)", "", jekyl.stat))
jekyl[[2]] <- jekyl.stat

servant.stats[is.hyde] <- list(jekyl)
```

Beast III/R
```{r}
#Beast III/R
is.beast.iii <- unique_servants == "Beast III/R"
servant.stats[[which(is.beast.iii)]][[2]] <- unlist(strsplit(servant.stats[[which(is.beast.iii)]][[2]], "/"))
```

Beast IV:L
```{r}
is.beast.iv <- grepl("Beast IV: L", unique_servants)
beast.iv.heading <- servant.stats[[1]][[1]]
beast.iv.info <- c("Lostbelt:Beast IV , Beast IV: Lost, Koyanskaya", "333", "16", "???", "???", "???", "???", "???", "???", "???", "???", "Saito Chiwa", "Wada Arco", "Beast", "None", "None", "None", "None", "None", "0", "Chaotic Evil", "Female", "Demonic, Divine, Female, Super Large, Wild Beast", "None | None | None | None")
servant.stats[[which(is.beast.iv)]][[2]] <- beast.iv.info
servant.stats[[which(is.beast.iv)]][[1]] <- beast.iv.heading
```

Mash Kyrielight
```{r}
is.mash <- which(grepl("Mash", unique_servants))
mash.headings <- servant.stats[[is.mash]][[1]]
mash.info <- servant.stats[[is.mash]][[2]]
maxHP.maxATK <- mash.headings == "Max HP" | mash.headings == "Max ATK"
mash.info[maxHP.maxATK] <- c("9,653", "14,248")
servant.stats[[is.mash]][[2]] <- mash.info
```

Now we can properly wrangle our information.
```{r}
get_alias <- function(stat.name, text) {
  index <- stat.name=="AKA"
  alias <- text[index]
  if(length(alias)==0){
    alias <- NA
  }
  return(alias)
}

servant.alias <- mapply(get_alias, stat.name=map(servant.stats, 1), text=map(servant.stats, 2))
```

```{r}
get_num_alias <- function(alias) {
  if (is.na(alias)==TRUE){
    return(0)
  }
  alias <- unlist(strsplit(alias, ","))
  alias <- unlist(strsplit(alias, ";"))
  return(unname(length(alias)))
}

alias.length <- unlist(lapply(servant.alias, get_num_alias))
```

```{r}
get_other_stats <- function(stat.name, stat){
  is.alias.traits <- stat.name == "AKA" | stat.name == "Traits"
  stat.name <- stat.name[!is.alias.traits]
  stat <- stat[!is.alias.traits]
  servant.stat.stat <- lapply(stat, gsub, pattern=",", replacement="")
  servant.stat.stat <- lapply(servant.stat.stat, gsub, pattern="%", replacement="")
  servant.stat.num <- suppressWarnings(!is.na(lapply(servant.stat.stat, as.numeric)))
  servant.stat.stat[servant.stat.num] <- as.numeric(servant.stat.stat[servant.stat.num])
  servant.stat.stat <- unlist(servant.stat.stat)
  names(servant.stat.stat) <- stat.name
  return(servant.stat.stat)
}

test <- mapply(get_other_stats, stat.name = map(servant.stats, 1), stat=map(servant.stats, 2), SIMPLIFY=FALSE)
```

```{r}
get_stat_stat<- function(stat.stat) {
  #Moral alignment
  alignment <- stat.stat["Alignments"]
  is.ascii <- grepl("[^ -~]", alignment)
  alignment <- iconv(alignment, "latin1", "ASCII", sub="_")
  stat.stat["Alignments"] <- alignment
  if(is.ascii == TRUE) {
    unlist(stat.stat["Alignments"] <- strsplit(stat.stat["Alignments"], "_+"))
  }
  else {
    stat.stat["Alignments"] <- strsplit(stat.stat["Alignments"], "\\s+")
  }
  stat.stat <- unlist(stat.stat)
  stat.stat[c("Alignments1", "Alignments2")] <- trimws(stat.stat[c("Alignments1", "Alignments2")])
  
  #Card hits
  hits <- unname(stat.stat["Hits"])
  is.hit <- names(stat.stat) == "Hits"
  stat.stat <- stat.stat[!is.hit]
  hits <- iconv(hits, "latin1", "ASCII", sub="") #ASCII spaces
  hits <- trimws(unlist(strsplit(hits, "\\|")))
  hits <- substr(hits, 1, 1)
  hit.names <- paste0(c("Quick.", "Arts.", "Buster.", "Extra."), rep("Hits"))
  names(hits) <- hit.names
  stat.stat <- c(stat.stat, hits)
  return(stat.stat)
  
  return(stat.stat)
}

test2 <- lapply(test, get_stat_stat)
```

We can finally merge our information into a dataframe.
```{r}
df.stats <- as.data.frame(do.call(rbind, test2))
df.stats <- data.frame("Servant.Name"=unique_servants, "Class" = servant.class, "Rarity"=servant.rarity, "Num.Alias"= alias.length , df.stats)

names(df.stats) <- gsub("\\.", "_", names(df.stats))
head(df.stats)
```

We want to replace values that do not contain information with NA. 
```{r}
# Replace N in hits with NA, None with NA, and ?? with NAs
has.q <- unname(unlist(lapply(lapply(df.stats, grepl, pattern="\\?"), sum)))>0
has.none <- unname(unlist(lapply(lapply(df.stats, grepl, pattern="None"), sum)))>0
is.N <- function(col) {
  is.n <- col == "N"
  
  if(sum(is.n) > 0){
    return(TRUE)
  } else {
    return(FALSE)
  }
}
has.N <- unlist(lapply(df.stats, is.N))
q.df <- df.stats[, has.q | has.none | has.N]

replace_na <- function(column){
  want.na <- column == "N" | grepl("\\?", column) | grepl("None", column) | column == ""
  column[want.na] <- NA
  return(column)
}

q.df <- as.data.frame(lapply(q.df, replace_na))
df.stats[, has.q | has.none | has.N] <- q.df
head(df.stats)
```

We want to change certain columns to be a numeric data type, not a character. We want to change ATK, Max ATK, LV. 100 Grail ATK, Lv. 120 Grail ATK, HP, Max HP, Lv. 100 Grail HP, Lv.120 Grail HP, Star Absorption, Star Generation, Np Charge ATK, Np Charge DEF, Death Rate, Quick Hits, Arts Hits, Buster Hits, and Extra Hits to numeric data types.
```{r}
df.names <- names(df.stats)
want.numeric <- grepl("ATK", df.names) | grepl("HP", df.names) | grepl("Hits", df.names) | grepl("NP", df.names) | grepl("Star", df.names) | grepl("Death_Rate", df.names)
df.stats[, want.numeric] <- suppressWarnings(lapply(df.stats[, want.numeric], as.numeric))
head(df.stats)
```

## Summer Servants
FGO releases summer alternatives every year, and they are almost all exclusively female (some Unknown genders, but there are no males). This might influence the gender distribution, so we'll check whether the servant is a summer servant or not.
```{r}
summer_servants <- read_html("https://fategrandorder.fandom.com/wiki/Category:Summer_Servants") %>%
  html_nodes(".wikitable") %>%
  html_nodes("td") %>%
  html_nodes("a") %>% 
  html_text2()
  
summer_servants <- summer_servants[summer_servants!=""]
```

```{r}
df_servant_list <- df.stats$Servant
summer_servants <- stri_trans_general(summer_servants, "Latin-ASCII")
summer_servants <- trimws(iconv(summer_servants, "latin1", "ASCII", sub=""))
df_servant_list <- stri_trans_general(df_servant_list, "Latin-ASCII")
df_servant_list <- trimws(iconv(df_servant_list, "latin1", "ASCII", sub=""))
```

```{r}
is.summer.servant <- df_servant_list %in% summer_servants
df.stats$is_Summer_Servant <- is.summer.servant
head(df.stats)
```

Now we can merge our dataframe with each servants' availability status.
```{r}
df_available <- as.data.frame(cbind("Servant_Name"=list_of_servants, "Availability"=list_of_availability))
fgo_stats <- merge(df_available, df.stats, by.x = "Servant_Name", all=TRUE, sort=FALSE)
head(fgo_stats)
```

```{r}
#Export the data frame
write.csv(fgo_stats,"fgo_stats.csv", row.names = FALSE)
```

# Exploratory Data Analysis
Now that we've cleaned our data, we can explore it. We want to see whether the game prefers releasing female servants over non-female servants. We can 

## Categorical Variables 

### Gender Frequency

Let's explore gender distribution of servants in relation to different variables. We won't explore servants with Unknown gender too much because there aren't many of them. The graphs below account for summer servants.
The graphs were created in Tableau.

## Gender {.tabset}

### Bar chart
![Gender Distribution](FGO_files/FGO Images/Gender Distribution.png)
Here is the distribution of servants by gender. Even if we exclude summer servants, there are more female servants than male servants. It seems that even if we aggregate male servants and unknown servants, there are still more female servants.

### Table
```{r}
round(rbind("Frequency"=xtabs(~Gender, data=df.stats), "Proportion"=xtabs(~Gender, data=df.stats)/nrow(df.stats)), 2)
```
There are 72 more female servants than male servants. The game has existed for 7 years, which means FGO has, on average, released 10 more female servants than male servants per year.
But remember, FGO releases 7 new servants every summer. Most of these servants are females, and none of them are male. Let's see what the numbers look like when we exclude summer servants.

### Table without Summer Servants
```{r}
round(rbind("Frequency"=xtabs(~Gender, data=df.stats[df.stats$is_Summer_Servant==FALSE, ]), "Proportion"=xtabs(~Gender, data=df.stats[df.stats$is_Summer_Servant==FALSE, ])/nrow(df.stats)), 2)
```
There are only 31 more female servants than male servants if we exclude summer servants. This averages to approximately 4.5 more female servants than male servants per year.


## Relationship between gender and rarity {.tabset}

### Bar Graph
![Gender Distribution by Rarity](FGO_files/FGO Images/Gender_Rarity.png)

Now this is interesting. There are more male servants than female servants among low rarity servants. Meanwhile, there are more female servants than male servants among high rarity servants. Low rarity servants are denoted by 1-3 while high rarity servants are 4-5. They are quantified by stars. In context, low rarity servants are easier to obtain compared to high rarity servants.

### Table
```{r}
rarity.gender <- xtabs(~Gender + Rarity, data=df.stats) # Frequency
rarity.gender
```

```{r}
round(t(t(rarity.gender)/colSums(rarity.gender)), 4) #proportion
```
Low rarity servants (1,2,3 stars) have a much higher proportion of male servants than female servants.
High rarity servants (4,5 stars) have a higher proportion of female servants than male servants.
High rarity servants tend to be more coveted by the player base since they have better stats.

### Table without Summer Servants
```{r}
rarity.gender.nosumm <- xtabs(~Gender + Rarity, data=df.stats[df.stats$is_Summer_Servant==FALSE,]) # Frequency
rarity.gender.nosumm
```

```{r}
round(t(t(rarity.gender.nosumm)/colSums(rarity.gender.nosumm)), 4) #proportion
```

Our data doesn't change much when we exclude summer servants. Despite the obvious inflation in female servants by summer servants, there is a still a higher proportion of high-rarity female servants than male servants.

## Gender by Availability {.tabset}

### Bar Chart
![Gender Distribution by Availability](FGO_files/FGO Images/Gender_Availability.png)
When categorized by availability, the only category that has more male servants than female servants is "Friend Point Only", which is associated with low rarity servants (1-2). 
The most exclusive category, "Limited", has much more female servants than male servants.

### Table
```{r}
gender.avail <- xtabs(~Availability + Gender, data=fgo_stats)
gender.avail #Frequency
```

```{r}
round(gender.avail/rowSums(gender.avail), 4) #proportion
```
We see that event reward and limited servants have signifcantlly more female servants than male servants. We won't include unplayable servants as having a significant difference because there aren't many of these servants.
Meanwhile, there are more Friend Point Only male servants.
This concurs with our Gender by Rarity findings. Event Servants are always 4-stars, and most Limited servants are high-rarity servants. Similarly, Friend Point Only servants are low rarity servants (1-2 stars).

### Table without Summer Servants
```{r}
gender.avail.nosumm <- xtabs(~Availability + Gender, data=fgo_stats[fgo_stats$is_Summer_Servant==FALSE,])
gender.avail.nosumm
```

```{r}
round(gender.avail.nosumm/rowSums(gender.avail.nosumm), 4) #proportion
```
Summer servants are either exclusively Event Rewards or Limited Servants. However, even if we exclude summer servants, Event Rewards and Limited Servants still have significantly more female servants than male servants.

## Gender by Class {.tabset}
### Bar Chart

![Gender Distribution by Class](FGO_files/FGO Images/Gender_Class.png)

Since there's lot of classes that don't have a lot of servants, we'll reduce the number of classes we have. We'll reduce Shielder, Ruler, Avenger, Moon Cancer, Foreigner, Pretender, Alter Ego, and Beast to Extra.
```{r}
extra.class <- c("Shielder", "Ruler", "Avenger", "Moon Cancer", "Foreigner", "Pretender", "Alter Ego", "Beast")
classes <- df.stats$Class
classes[classes %in% extra.class] <- "Extra"
```

### Table
```{r}
gender.class <- xtabs(~classes + Gender, data=df.stats)
gender.class
```
According to our table, Assassins and Extra classes have significantly more female servants than male servants.
Berserker, Caster, Lancer, and Rider classes have more female servants, but it could be because of the inflation of summer servants.
Surprisingly, only Archer classes have more male servants than female servants (by 1!)

### Table without Summer Servants
```{r}
not.summer.classes <- classes[df.stats$is_Summer_Servant==FALSE]
class.gender.nosumm <- xtabs(~not.summer.classes + Gender, data=df.stats[df.stats$is_Summer_Servant==FALSE,])
class.gender.nosumm
```
Removing summer servants gives us some interesting information. As expected, Assassin and Extra classes have significantly more female servants.
Caster and Lancer classes still have more female servants than male servants.
But now we have 3 classes that have more male servants than female servants! Archer seems to have significantly more male servants than female servants while Sabers and Riders just have a few more male servants than female servants.
There is an equal number of male and female servants among the Berserker class.

### Average Rarity
We can look at the average rarity of each servant by class and gender.
```{r}
paste0("Average Rarity of Servants in each Class by Gender")
num.rarity <- as.numeric(df.stats$Rarity)

round(xtabs(num.rarity ~ classes + Gender, data=df.stats)/gender.class, 3)
```
We see that for all categories, the average rarity for female servants by class is higher than the average rarity for male servants. This seems in line with our previous findings. There are less male servants than female servants, but there are more low-rarity male servants than low-rarity female servants. Hence the average rarity of male servants should be lower than the average rarity of female servants.
Servants of unknown rarities have fairly high average rarities. This makes sense since servants with Unknown genders are exclusively high-rarity servants.

### Average Rarity without Summer Servants
Summer servants are exclusively high-rarity servants. Let's see our average rarity looks like when we exclude summer servants.
```{r}
paste0("Average Rarity of Servants in each Class by Gender without Summer Servants")
num.rarity.nosumm <- as.numeric(df.stats$Rarity[df.stats$is_Summer_Servant == FALSE])

round(xtabs(num.rarity.nosumm ~ not.summer.classes + Gender, data=df.stats[df.stats$is_Summer_Servant == FALSE,])/class.gender.nosumm, 3)
```
Removing summer servants doesn't appear to change our conclusion, but some changes are noteworthy.
The average rarity for females that are Sabers, Caster, and Extra increased. Summer servants actually lowered these average rarities.

## {-}

### Qualitative Takeaways
- There are more high-rarity female servants than non-female servants. There are also less low-rarity female servants than non-female servants.
- There are more limited and event reward female servants than non-female servants. 
- Summer servants affect the gender discrepancy out of all servants, but not servants within categories.

### Possible Future Work
- Rarity and availability are related. Event servants tend to be exclusively 4-stars while most limited servants are high-rarity servants. We could determine the relationship between rarity and availability with gender.
- Servants are based off of historical/mythical figures, but FGO has a reputation for changing the genders of historical characters. For example, Artoria Pendragon, a female servant, is based off of the historically male King Arthur. There are also some characters who have unknown genders when they appear to be female or male. For instance, Kama officially has an unknown gender but appears feminine. Arjuna (Alter) officially has an unknown gender but is widely recognized as male. Is there a difference in distribution if we compare the distribution of the characters' historical genders to their in-game gender?

## Quantative variables
There are several atk and hp values such as ATK and HP (starting attack and hp at level 1), Max ATK and Max HP (attack and hp at max level), etc.
Generally, servants gain attack and hp when they level up. Obviously, there is a positive relationship between level and stat, but is it linear? 
I wanted to check if it was a linear increase so I would only have to analyze one set of ATK and HP values and assume the same results for the other sets of ATK and HP values.
```{r}
atk <- na.omit(df.stats[, c(grepl("ATK", names(df.stats)) & !grepl("NP", names(df.stats)) | grepl("Rarity", names(df.stats)))])
hp <- na.omit(df.stats[, c(grepl("HP", names(df.stats)) & !grepl("NP", names(df.stats)) | grepl("Rarity", names(df.stats)))])

get_r2_atk <- function(row) {
  rarity <- row["Rarity"]
  max_level <- 0
  
  if(rarity == 1) {
    max_level <- 60
  } else if(rarity==2) {
    max_level <- 65
  } else if(rarity==3) {
    max_level <- 70
  } else if(rarity==4) {
    max_level <- 80
  } else {
    max_level <- 90
  }
  
  lvs <- c(1, max_level, 100, 120)
  attack <- unlist(row[grepl("ATK", names(row))])
  
  return(summary(lm(attack ~ lvs))$r.squared)
}

get_r2_hp <- function(row) {
  rarity <- row["Rarity"]
  max_level <- 0
  
  if(rarity == 1) {
    max_level <- 60
  } else if(rarity==2) {
    max_level <- 65
  } else if(rarity==3) {
    max_level <- 70
  } else if(rarity==4) {
    max_level <- 80
  } else {
    max_level <- 90
  }
  
  lvs <- c(1, max_level, 100, 120)
  hp <- unlist(row[grepl("HP", names(row))])
  
  return(summary(lm(hp ~ lvs))$r.squared)
}


atk_r2 <- unname(apply(atk, 1, get_r2_atk))
hp_r2 <- unname(apply(hp, 1, get_r2_hp))

paste("Number of servants with attack growth not described by linear fit:", sum(atk_r2<0.9))
paste("Number of servants with hp growth not described by linear fit:", sum(hp_r2<0.9))
```
Because the coefficient of determination (r^2) > 0.9, we see that every servant with complete ATK and HP values generally have linear increases in stat by level.

Some entries don't have ATK stats, HP stats, or other related stats. Let's check which servants have incomplete attack/hp stats.
```{r}
atk_hp <- df.stats[, c("Servant_Name", "ATK", "HP", "Max_ATK", "Max_HP", "Lv_100_Grail_ATK", "Lv_100_Grail_HP", "Lv_120_Grail_ATK", "Lv_120_Grail_HP")]
atk_hp[!atk_hp$Servant_Name %in% drop_na(atk_hp)$Servant_Name, ]
```
We can omit these from our plots since there aren't too many of them.

```{r}
quant_df <- df.stats[atk_hp$Servant_Name %in% drop_na(atk_hp)$Servant_Name, ]
head(quant_df)
```

Now let's plot base atk vs. base hp.
```{r}
quant_df %>%
  ggplot(aes(x = ATK, y=HP)) + geom_point() +
  ggtitle("Base ATK vs Base HP")
```

Our graph shows a relatively positive linear trend between ATK and HP with higher ATK values corresponding to higher HP values. But this doesn't make sense. If one stat is good, shouldn't the other stat be worse? 
Stats and strengths are also usually separated by rarity. Low-rarity characters tend to be weaker; high-rarity characters tend to be stronger. So let's see what happens when we group these stats by rarity.
```{r}
quant_df %>%
  ggplot(aes(x = ATK, y=HP, color=Rarity)) + geom_point() +
  scale_color_brewer(palette="Dark2") + 
  ggtitle("Starting ATK vs Starting HP by Rarity")
```

Now we can see that the relationship between ATK and HP is inverse, just like we thought. Let's see if different genders have different stats.

## Plots {.tabset}

### Base
```{r}
quant_df %>%
  ggplot(aes(x = ATK, y=HP, color=Gender)) + geom_point() +
  scale_color_brewer(palette="Accent") +
  facet_wrap("Rarity")
```

### Max
```{r}
quant_df %>%
  ggplot(aes(x = Max_ATK, y=Max_HP, color=Gender)) + geom_point() +
  scale_color_brewer(palette="Accent") +
  facet_wrap("Rarity")
```

### LV 100
```{r}
quant_df %>%
  ggplot(aes(x = Lv_100_Grail_ATK, y=Lv_100_Grail_HP, color=Gender)) + geom_point() +
  scale_color_brewer(palette="Accent") +
  facet_wrap("Rarity")
```

### LV 120
```{r}
quant_df %>%
  ggplot(aes(x = Lv_120_Grail_ATK, y=Lv_120_Grail_HP, color=Gender)) + geom_point() +
  scale_color_brewer(palette="Accent") +
  facet_wrap("Rarity")
```

## {-}

It doesn't look like there's any notable difference in stats by gender. Female servants and male servants seem to have relatively similar trends and stats within rarities.
Let's take a look at the average base attack and average base hp for each gender and each rarity.

## Average Attack by Tables {.tabset}
### Base
```{r}
round(xtabs(ATK ~ Rarity + Gender, data=df.stats)/xtabs(~Rarity + Gender, data=df.stats), 3)
```

### Max
```{r}
round(xtabs(Max_ATK ~ Rarity + Gender, data=df.stats)/xtabs(~Rarity + Gender, data=df.stats), 3)
```

### LV 100
```{r}
round(xtabs(Lv_100_Grail_ATK ~ Rarity + Gender, data=df.stats)/xtabs(~Rarity + Gender, data=df.stats), 3)
```

### LV 120
```{r}
round(xtabs(Lv_120_Grail_ATK ~ Rarity + Gender, data=df.stats)/xtabs(~Rarity + Gender, data=df.stats), 3)
```


## Average HP by Tables {.tabset}
### Base
```{r}
round(xtabs(HP ~ Rarity + Gender, data=df.stats)/xtabs(~Rarity + Gender, data=df.stats), 3)
```

### Max
```{r}
round(xtabs(Max_HP ~ Rarity + Gender, data=df.stats)/xtabs(~Rarity + Gender, data=df.stats), 3)
```

### LV 100
```{r}
round(xtabs(Lv_100_Grail_HP ~ Rarity + Gender, data=df.stats)/xtabs(~Rarity + Gender, data=df.stats), 3)
```

### LV 120
```{r}
round(xtabs(Lv_120_Grail_HP ~ Rarity + Gender, data=df.stats)/xtabs(~Rarity + Gender, data=df.stats), 3)
```

## {-}

### Quantitative Takeaways
- There doesn't appear to be a trend between stats and gender, meaning there is no statistical advantage between genders. However, we do see a trend between stats and rarity.

# Modeling and Machine Learning
From our exploratory data analysis, we saw that availability, rarity, and whether the servant is a summer servant or not seem to be correlated with gender. Class might have an impact on gender. ATK and HP seem to have no relation with gender, so we can omit it.
We can reduce gender to a binary outcome: Is female or is not female. Because we have two outcomes, we can fit the data using logistic regression. We can also reduce Class to fewer classes. Servants that are Ruler, Avenger, Moon Cancer, Foreigner, Alter Ego, Pretender, and Shielder will be categorized as Extra.
Rarity will be an ordinal variable.
```{r}
model.df <- fgo_stats[, c("Servant_Name", "Rarity", "ID", "Class", "Availability", "Gender")]
fgo_stats$Gender[fgo_stats$Gender != "Female"] <- FALSE
fgo_stats$Gender[fgo_stats$Gender == "Female"] <- TRUE
fgo_stats$Gender <- as.logical(fgo_stats$Gender)
not.extra <- c("Saber", "Archer", "Lancer", "Rider", "Caster", "Assassin", "Berserker")

fgo_stats$Class[!fgo_stats$Class %in% not.extra] <- "Extra"
fgo_stats$Rarity <- as.factor(fgo_stats$Rarity)
```

We separate our data into two datasets: A training set and a testing set.
```{r}
set.seed(123)
train <- fgo_stats %>% sample_frac(0.6)
is.train <- fgo_stats$ID %in% train$ID
testing <- fgo_stats[!is.train, ]
head(train)
```

We'll check three models to see how well they work. The first model is the additive model with categories is_Summer_Servant, Availability, Class, and Rarity
The second model is the additive model without the category Class.
We can test if the the model without the category Class adequately fits the model through an anova test. 
Formally, our null and alternate hypothesis are the following:

$$ H_0: \text{The reduced model } 
\\Gender = \text{is_Summer_Servant + Availability + Rarity } 
\\\text{ adequately fits the model compared to the full model } 
\\Gender = \text{is_Summer_Servant + Availability + Rarity + Class.}$$

$$ H_1: \text{The reduced model does not adequately fit the model compared to the full model.} $$

```{r}
mod.noclass <- glm(Gender ~ is_Summer_Servant + Availability + Rarity
                 ,data=train, family="binomial")
mod.class <-  glm(Gender ~ is_Summer_Servant + Availability + Class + Rarity
                 ,data=train, family="binomial")

anova(mod.noclass, mod.class, test="Chisq")
```
From our anova test, we obtain a p-value = 0.3619 which is larger than our significance level (alpha=0.05). The reduced model (the model without the Class category) is a better fit for the data.

Now let's compare this to our third model, the two-way interaction model between Availability, Rarity, and is_Summer_servant.

$$ H_0: \text{The reduced model } 
\\Gender = \text{is_Summer_Servant + Availability + Rarity } 
\\\text{ adequately fits the model compared to the full model } 
\\Gender = \text{(is_Summer_Servant + Availability + Rarity +}
\\ \text{is_Summer_Servant:Availability + is_Summer_Servant:Rarity + Availability:Rarity)}$$
$$ H_1: \text{The reduced model does not adequately fit the model compared to the full model.} $$
```{r}
mod.twoway <- glm(Gender ~ (is_Summer_Servant + Availability + Rarity)^2
                 ,data=train, family="binomial")
anova(mod.noclass, mod.twoway, test="Chisq")
```
Again, our p-value = 0.2773 is fairly large, which indicates that the reduced model or the additive model is a better fit to the model than the two-way interaction model.

The summary for this model is shown below.
```{r}
summary(mod.noclass)
```
We have the logistic regression model where logit(p) = 0.4969 + is_Summer_Servant + Availability + Rarity with the baseline categories (or logit(p) = 0.4969) is_Summer_Servant = FALSE, Availability = Event Reward, and Rarity = 1. This means that our intercept, or the logit(y) = 0.4969 represents the log-odds a servant that is not a summer servant, is an event reward, and has a 1-star rarity is female.

Let's see how good our model is at classifying entries into genders.

## Predictions {.tabset}

### Training
```{r}
train.pred <- predict(mod.noclass, newdata=train, type="response")
train.pred.table <- table(train$Gender, train.pred >= 0.5)
train.pred.table
```

```{r}
accuracy.train <- sum(diag(train.pred.table)/sum(train.pred.table))
paste0("Training Accuracy: " , round(accuracy.train, 4)) #0.6883721
```
Our model accurately predicts 68.8% of the test data properly.

### Testing
```{r}
test.pred <- predict(mod.noclass, newdata=testing, type="response")
test.true <- test.pred > .5
test.pred.table <- table(testing$Gender, test.true)
test.pred.table
```

```{r}
accuracy.test <- sum(diag(test.pred.table)/sum(test.pred.table))
paste0("Testing accuracy: ", round(accuracy.test, 4)) #0.729927
```
Our model accurately predicts 73.0% of the training data properly.

## {-}

We can estimate the probability a servant will be female through following function:

logit(p) = 0.4969 + is_Summer_Servant + Availability + Rarity with the baseline categories is_Summer_Servant = FALSE, Availability = Event Reward, and Rarity = 1.
Where
$$ p = \frac{exp(logit(p))}{1+exp(logit(p))}$$
# Summary and Conclusion
- Our goal was to investigate whether there was a gender bias towards releasing female servants. Through rvest, ggplot, some basic Tableau, and hypothesis tests, we visualized and quantified any differences.
- If we include summer servants, then there is a higher proportion of female servants than non-female servants. If we don't include summer servants, then there is not a significant difference in proportion between female and non-female servants.
- There are gender discrepancies among certain categories. We notice that low-rarity servants have a higher proportion of non-female servants and high-rarity servants have a higher proportion of female servants.
- Event reward and Limited servants have a higher proportion of female-servants, which might be correlated with higher-rarities.
- We didn't find any significant differences in stats by gender, but there are differences in stats by rarity.
- Our machine learning regression predicted approximately 73.0% of our testing data accurately. 

# Future Work
- Is there a possible reason why FGO releases more female servants? We can possibly look into revenue insights and player preferences such as servant popularity rankings.
- Can we model and predict the gender of a servant given certain parameters? I wasn't too sure how to account for possible collinear  
- Is there a trend between release date/banner and gender? Summer servants are only released during the summer and are usually only available during the summer.
